% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage{courier}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% omat
\usepackage{graphicx}
\usepackage[font={small,it}]{caption}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% paketit algoritmien esittämistä varten
\usepackage{algorithm}
\usepackage{algpseudocode}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Rinnakkainen reitinhaku}
\author{Santeri Martikainen}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{}

% The following can be used to specify keywords and classification of the paper:

\keywords{reitinhaku, multi-agent pathfinding, MAPF}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

Reitinhaussa on pohjimmiltaan kyse mahdollisimman suoran ja nopean polun löytämisestä kahden pisteen välillä jossakin topologiassa. Topologia, eli kenttä tai alue, voi olla reaalimaailmassa, kuten tieverkosto autonavigaattorin reitinhaussa tai vaikkapa kokoonpanolinjan robotin käytettävissä oleva liikkumatila. Topologia voi myös olla täysin virtuaalinen, kuten tietokonepelien pelimaailmat. Muita käyttökohteita ovat muun muassa liikenteen ja väkijoukkojen mallintaminen, poliisin ja pelastustoimen tehtävät, sekä tietoliikenneverkot. Käyttökohteesta riippumatta topologia, jossa reittejä etsitään, on mallinnettava tietorakenteiksi sen läpikäyntiä varten.

Oli reitinhaun sovelluskohde mikä hyvänsä, mikäli varsinaista reitinhakua tarvitaan ei reitin löytäminen jokaisella suorituskerralla voi olla täysin suoraviivaista ja triviaalia. Mikäli näin olisi, asia voitaisiin ratkaista yksinkertaisesti laskemalla lyhin etäisyys mitä pitkin liikkua suoraan kohteeseen ja toimia sen mukaan. Kysymys on siis reittien löytämisestä tietyin reunaehdoin. Esimerkiksi navigaattoria käyttävää autoilija haluaa kaikella todennäköisyydellä ajaa määränpäähänsä lyhintä reittiä teitä pitkin oikaisematta yhdenkään metsän tai järven lävitse.

Tässä tutkielmassa tarkastellaan ensin reitinhakua itsessään ja sen ratkaisemista yhden toimijan (agent) reitinhakualgoritmeilla. Jäljempänä käsittelemme monen yhtaikaisen toimijan reitinhakua (multi-agent pathfinding, MAPF) ja siihen kehitettyjä algoritmeja. 

% Write some science here.

% Esimerkkilause ja lähdeviite~\cite{esimerkki}.

\section{Reitinhaku}

Reitinhaun toteuttaminen jakaantuu kahteen vaiheeseen: Toimintaympäristöstä tai topologiasta muodostetaan ensin yksinkertaistettu malli, minkä jälkeen sitä käydään läpi jollakin algoritmilla halutun reitin löytämiseksi. Algoritmia ohjaa heuristiikkafunktio jolla arvioidaan etäisyyttä kohteeseen ja voidaan siten vertailla eri reittivaihtoehtojen keskinäistä paremmuutta. Jonkin reitin paremmuuteen muihin nähden voi vaikuttaa pituuden lisäksi myös sen nopeus.

Topologiasta riippumatta mallinnuksen tuloksena on useimmiten verkko \texttt{G=(V,E)}, missä \texttt{V} (vertex) on joukko solmuja ja \texttt{E} (edge) joukko solmuja yhdistäviä kaaria. Liikkuminen voi esimerkiksi tapahtua solmusta toiseen, tai sitten solmut voivat edustaa kiintopisteitä joiden läheisyydessä voidaan liikkua ilman erillistä reitinhakua. Solmut voivat myös toimia esteinä, jolloin niihin liikkuminen on estetty. Tämä voi myös olla vain solmun väliaikainen tila esimerkiksi jonkun toisen toimijan ollessa liikkumisen tiellä. Verkko voi siis olla dynaaminen, eli sen rakenne saattaa muuttua kesken reittien läpikäymisen, mikä asettaa omat haasteensa reitinhaulle~\cite{botea13, algfoor15}. Topologia voidaan toisinaan mallintaa myös puurakenteena~\cite{khorshid2011polynomial}.

Edellämainittujen esteiden ja muuttuvan toimintaympäristön lisäksi reitinhaun keskeisiä ongelmia on resurssien käyttö. Mitä laajemmassa topologiassa reitinhaku suoritetaan, sitä enemmän laskentaresursseja (muistia, prosessoriaikaa) siihen menee. Joissakin tilanteissa voidaan tyytyä osittaiseen reitinhakuun, eli reittiä ei lasketa loppuun asti, vaan ainoastaan johonkin tiettyyn ennaltamäärättyyn pisteeseen ja uusi reitinhaku tehdään kun jokin välietappi on saavutettu. Tässä on luonnollisesti varmistuttava siitä, että valittuun suuntaan lähteminen todella mahdollistaa perille pääsemisen. Toinen lähestymistapa on kaikkien mahdollisten reittien laskeminen ennakkoon, jolloin haluttu reitti kahden sijainnin välillä yksinkertaisesti haetaan taulukosta tarvittaessa. Tämän menetelmän heikkoutena on, että kyseisestä taulukosta saattaa tulla niin suuri, että varsinainen reitinhaku on nopeampi toteuttaa. Niinikään se vaatii käytännössä mainitun taulukon pitämistä jatkuvasti muistissa.

%pelimaailman tyypillinen tilanne tähän

%Tyypillisesti kenttä muodostetaan soluista (cell), joista toisinaan käytetään myös nimitystä laatta (tile). Solut ovat käytännössä monikulmioita, usein joko kolmioita, neliöitä tai kuusikulmioita. Edellämainitut muodot ovat ainoat monikulmiot, joita yhdistelemällä voidaan jokin alue kattaa yhtenäisesti ilman väliin jääviä aukkoja, mikäli kenttä halutaan mallintaa keskenään samankokoisilla soluilla. Mallinnus voidaan tehdä myös vaihtelevan kokoisilla monikulmioilla. Solut joissa kentällä voidaan liikkua muodostavat reitinhaussa käytettävän verkon (graph) solmut (vertex)~\cite{botea13, cui11}.

Reitinhaun standardialgoritmi on jo pitkään ollut Dijkstran algoritmiin perustuva A* (eli A-star tai A-tähti), josta on kehitetty lukuisia eri variantteja eri toimintaympäristöjä ja tarpeita silmälläpitäen. Sen etuja on, että se pystyy varmuudella löytämään reitin kohteeseen, jos sellainen on ylipäätään olemassa. Niinikään se antaa parhaan mahdollisen reitin useista vaihtoehdoista, mikäli sen heuristiikkafunktio ei yliarvioi etäisyyttä kohteeseen~\cite{cui11, sharon15, botea04}. Tärkeisiin heuristisiin algoritmeihin kuuluvat myös iteratiivinen syvyys-A* (iterative-deepening-A*, IDA*) ja syvyyssuuntainen-haarautuva-rajattu (depth-first branch-and-bound, DFBnB)~\cite{felner2004additive}. Resurssitarpeiden kurissapitämiseksi on kehitetty myös erilaisia hierarkiamalleja soveltavia algoritmeja, kuten hierarkinen reitinhaku-A* (hierarchical pathfinding A*, HPA*).

\subsection{Dijkstran algoritmi}

Edsger Dijkstra esitteli 1959 algoritmin, joka etsii lyhimmät reitit kaikkien graafissa esiintyvien solmujen välillä~\cite{dijkstra1959numerische}. Kyseessä on leveyssuuntaista hakua toteuttava algoritmi. Tämä tarkoittaa, että ensin tutkitaan kaikki lähtösolmun naapurit, sitten naapureiden naapurit ja niin edelleen, kunnes joko kaikki solmut on käyty läpi, tai jokin algoritmille asetettu pysähtymisehto on täyttynyt. Tällainen ehto voi olla esimerkiksi reitin löytyminen kahden määritellyn solmun välillä.

Kuvassa \ref{dijkstra} nähdään miten viisisolmuisessa graafissa löydetään lyhyimmät reitit solmujen (ympyrät) välillä. Solmuja yhdistää joukko suunnattuja kaaria, joiden vieressä oleva luku kuvaa kaaren painoa, eli sen kulkemisen hintaa. Ainoastaan lähtösolmu $s$ on tässä vaiheessa saanut numeroarvon, joka kuvaa sen etäisyyttä lähtösolmuun. Kohdassa b on tutkittu ne solmut joihin edellisestä solmusta pääsee, sekä asetettu niille etäisyysarvot. C-kohdassa on jälleen jatkettu yksi askel eteenpäin, mutta on huomattava kuinka solmun $t$ arvo on nyt muuttunut b-kohtaan verrattuna. Tämä johtuu siitä, että $y$-solmun kautta kulkeva reitti on havaittu lyhyemmäksi kuin suora yhteys $s$- ja $t$-solmujen välillä. Tätä jatketaan niin kauan kunnes koko graafi on käyty läpi ~\cite{dijkstra1959numerische, skiena1990dijkstra}.
Dijkstran algoritmia käytetään edelleen muun muassa joissakin tietoliikenneverkkojen reititysprotokollissa.

\begin{figure}
\captionsetup{width=\linewidth}
\includegraphics[width=\textwidth, keepaspectratio]{dijkstra}
\centering
\caption{Graafin läpikäynti Dijkstran algoritmilla~\cite{dijkstra_kuva}.}
\label{dijkstra}
\end{figure}

\subsection{A*-algoritmi}

Dijkstran algoritmiin perustuva A* toteuttaa niin sanottua paras ensin -tyyliä, jossa jokaisen solmun tai solun kohdalla pyritään ensiksi etenemään suoraan kohti maalia. Jos tiellä on jokin este, algoritmi pyrkii kiertämään sen. Tämä tapahtuu etenemällä valitsemalla tähänastisen reitin viereisistä soluista ne joista arvioidaan olevan lyhyin etäisyys maaliin. Tätä jatketaan kunnes joko päästään kohteeseen, tai selviää että reittiä ei ole. A* poikkeaa siis Dijkstran algoritmista hakeutumalla koko ajan maalin suuntaan, mikä tapahtuu heuristiikkafunktion avulla (algoritmi \ref{alg_astar}:n rivi 13).

Kaikille algoritmin käsittelemille solmuille lasketaan arvo kaavalla \begin{equation}\label{astarkaava}{f(n) = g(n)+h(n)}\end{equation} missä $g(n)$ on lyhin tunnettu reitti lähtösolmusta solmuun $n$ ja $h(n)$ on heuristinen arvio etäisyydestä maalisolmuun~\cite{sharon15, stout96}. Näin jokaisen läpikäydyn solmun kohdalla tiedetään sille lasketusta arvosta kuinka suoralla reitillä kohteeseen ollaan. Solmuille voidaan myös asettaa edellämainittuun kaavaan lisättävä arvo tekemään siihen siirtymisestä hintavampaa ja näin mallintaa hitaampaa kulkuyhteyttä kahden paikan välillä.

Kuvassa \ref{dijkstrab} on ylempänä havainnollistettu Dijkstran algoritmin löytämä reitti yksinkertaisessa ruudukossa. Liikkuminen on rajoitettu niin sanottuun Manhattan -tyyliin, missä sallitut kulkusuunnat ovat neljä pääilmansuuntaa. Esteenä toimivat solmut on väritetty tummanharmaalla ja algoritmin läpikäymät solmut turkoosilla. Jälkimmäisen värisävyt kuvaavat laskennallista etäisyyttä vaaleanpunaiseen lähtösolmuun. Kuten kuvasta nähdään, Dijkstra käy läpi varsin suuren osan kentän solmuista, mutta löytää suorimman reitin violetilla merkittyyn kohteeseen.

Saman kuvan alemmalla puoliskolla nähdään miten A*-algoritmin toimintaperiaate poikkeaa Dijkstran algoritmista: Tutkittuja solmuja on paljon vähemmän heuristiikan ohjatessa läpikäynnin suuntaa. Vaikka reitit hieman poikkeavatkin toisistaan, ne ovat annettujen ennakkoehtojen valossa yhtä pitkiä.

\begin{figure}
\captionsetup{width=\linewidth}
\includegraphics[width=\textwidth, keepaspectratio]{dijkstra_astar}
\centering
\caption{Ylempänä reitinhaku Dijkstran algoritmilla ja alempana A*-algoritmilla~\cite{astar_kuva}.}
\label{dijkstrab}
\end{figure}



\begin{algorithm}
\caption{A*-algoritmin pseudokoodi}
\label{alg_astar}
\begin{algorithmic}[1]
	\Procedure{Astar}{startnode, goalnode}
	\State initialize the open list
	\State initialize the closed list
	\State put the starting node on the open list (you can leave its f at zero)
	\newline
	\While{the open list is not empty}
		\State find the node with the least f on the open list, call it 'q'
		\State pop q off the open list
		\State generate q's 8 successors and set their parents to q
		\For{each successor}
			\State \textbf{if} successor is the goal \textbf{then}
			\State \indent stop search
			\State successor.g = q.g + distance between successor and q
			\State successor.h = distance from goal to successor
			\State successor.f = successor.g + successor.h
			\State \textbf{if} a node with the same position as successor is in the OPEN \indent\indent \: list which has a lower f than successor \textbf{then}
			\State \indent skip this successor
			\State \textbf{if} a node with the same position as successor is in the CLOSED \indent\indent \: list which has a lower f than successor \textbf{then}
			\State \indent skip this successor
			\State otherwise, add the node to the open list
		\EndFor
		\State push q on the closed list
	\EndWhile
	\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Hierarchical Pathfinding A* (HPA*)}

Tämä algoritmi poikkeaa A*:stä siinä, että reitinhaun apuna käytetään yhtä tai useampaa abstraktiotasoa. HPA*:n kehittäjät A.Botea ja M.Müller käyttävät autovertausta havainnollistamaan algoritmin toimintaa: Kaupungista toiseen ajava autoilija ei ole kiinnostunut kaikista mahdollisista yksityiskohdista matkansa varrella, vaan häntä lähinnä kiinnostaa reitti lähtöpisteestä oikeaan suuntaan vievälle valtatielle, ja kohdekaupunkiin saavuttaessa reitti valtatieltä varsinaiseen määränpäähän. Itse valtatien ajamisen voidaan tässä esimerkissä siis nähdä olevan jokseenkin triviaalia toimintaa, joka ei vaadi sen kummempia toimenpiteitä. Tarkoitus on siis pyrkiä reitinhaun tehokkuuteen eliminoimalla sellaista laskentaa, joka liittyy esteettömien alueiden ylittämiseen~\cite{botea04}.
Kuvassa ~ref{hpa} nähdään abstraktion vaiheet testiruudukossa. Ruudut $S$ ja $G$ merkitsevät lähtö- ja maaliruutuja, ja mustaksi värjätyt ruudut esteitä. Kohdassa b on alkuperäiseen ruudukkoon merkitty kapeilla mustilla viivoilla alueen jako klustereihin, ja alimpana nähdään vasemman yläneljänneksen klusterit harmaalla merkittyine siirtymineen. Tässä esimerkissä on käytetty raja-arvona kuutta ruutua, jolloin alle raja-arvon levyiset avoimet ruutualueet kahden klusterin välillä saavat yhden siirtymän ja muualla siirtymiksi merkitään avoimien ruutualueiden reunat.
Kun kentästä on näin muodostettu abstraktiomalli, sitä käytetään reitinhaussa ohjaamaan A*-algoritmia oikeaan suuntaan. Kyseessä on kolmivaiheinen menettely: Ensin absraktiomalliin liitetään aloitus- ja lähtösolmut $S$ ja $G$. Tämän jälkeen abstraktiomallia käydään läpi A*:llä saamaan selville ne klustereita yhdistävät siirtymät, joiden kautta maaliin tulee kulkea. Tämä tuottaa joukon välietappeja, joita käytetään varsinaisen reitin selvittämiseen. Välietapit pitävät huolen siitä, että reitinhaku etenee koko ajan oikeaan suuntaan, jolloin voidaan välttää turhaa työtä.
Algoritmin toimintaa voidaan tietyissä tilanteissa parantaa lisäämällä abstraktiotasoja, jolloin jokainen uusi abstraktiotaso on edellistä karkeampi esitys kentän topologiasta.

\begin{figure}
\captionsetup{width=1\linewidth}
\includegraphics[scale=1]{hpa}
\centering
\caption{Ylärivillä 40x40 -ruudukon jakaminen 16:een klusteriin HPA*-algoritmin esiprosessoinnissa, alla vasemman yläneljänneksen klustereiden siirtymät~\cite{botea04}.}
\label{hpa}
\end{figure}

\section{Rinnakkainen reitinhaku}

Rinnakkaisessa reitinhaussa on yleensä useita, joskus jopa satoja tai tuhansia, eri toimijoita. Tällainen monen toimijan rinnakkainen reitinhaku (multi-agent pathfinding, MAPF) tuo yksittäisen toimijan reitinhakuun verrattuna uusia ongelmia. On muun muassa ratkaistava sallitaanko reittien risteäminen, voiko kaksi tai useampi toimijaa olla samaan aikaan samassa paikassa, tuleeko liikkumista porrastaa odottamalla että reitti edessä vapautuu ja tuleeko toimijan väistää ollessaan toisen toimijan tiellä~\cite{erdem13}. Näiden ongelmien ratkaisemiseen kehitetyistä algoritmeja useimmat hyödyntävät A*-algoritmia jollakin tapaa~\cite{sharon15}.

Mitä enemmän toimijoita tutkittavalla alueella on, sitä oleellisemmaksi muodostuu yhteentörmäyksien ja tahattoman reittien sulkemisen välttäminen. Yksi oleellinen ero lähestymistavoissa on käsitelläänkö toimijoita yhdistettynä (coupled) toimijana, vai toisistaan erotettuina (decoupled) toimijoina. Erotetussa menetelmässä reitit lasketaan jokaiselle toimijalle erikseen ja mahdolliset yhteentörmäykset ratkaistaan valitulla menettelyllä sikäli kuin niitä tapahtuu. Tämä menetelmä on tyypillinen tilanteille, joissa toimijoita on verrattaen paljon~\cite{sharon2013}. Yhdistetyssä menetelmässä kaikkia toimijoita käsitellään sen sijaan kokonaisuutena. Tämä voidaan toteuttaa esimerkiksi varaamalla graafin solmuja toimijoiden käyttöön siksi aikaa kun näiden odotetaan oman reitinhakunsa perusteella niissä olevan. Lukuisten toimijoiden yhtäaikainen huomioonottaminen luonnollisesti lisää ongelman monimutkaisuutta.

Yksi graafien ominaisuuksia on \textit{haarautuvuus} (branching). Tällä tarkoitetaan keskimääräistä lukumäärään naapurisolmuja, joihin jostakin graafin solmusta voidaan liikkua. Jos meillä on graafi, jonka haarautuvuus on $b$, niin erotetussa menetelmässä jokaisella toimijalla on $O(b+1)$ mahdollista liikettä, eli siirtymät toisiin solmuihin ja paikallaan odottaminen. Yhdistetyssä menetelmässä on sen sijaan joka askeleella otettava myös huomioon $k$ toimijaa, jolloin mahdollisia liikkeitä on $O(b+1)^k$. Tämä hidastaa reittien laskemista~\cite{sharon2013}.

Kuten edellä todettiin, useimmat rinnakkaisen reitinhaun ratkaisemiseen kehitetyt menetelmät ovat A*-pohjaisia. A*-agoritmi vaatii kuitenkin verrattaen paljon resursseja käyttöönsä, mikäli kyse on laajemmasta reitinhakuongelmasta. Siksi onkin kehitetty useita erilaisia lähestymistapoja, joilla pyritään pitämään läpikäytävien solmujen määrä, ja siten laskentaresurssien tarve, mahdollisimman pienenä.



\section{A*-pohjaiset rinnakkaisen reitinhaun algoritmit}

%kuvaukset:\newline
%Pattern Databases\newline
%Independence detection (ID)\newline
%Operator decomposition (OD)\newline
%Enhanced partial expansion A* (EPEA*)
\subsection{Local Repair A* (LRA*)}

LRA* on yleistermi joukolle A*-pohjaisia algoritmeja, jotka jakavat saman toimintaperiaatteen: Jokainen toimija etsii reitin A*:lla ja seuraa sitä siihen asti kunnes siirtyminen seuraavaan solmuun saisi aikaan yhteentörmäyksen jonkun toisen toimijan kanssa, eli solmu johon pitäisi siirtyä on varattu. Tällöin tehdään uusi A*-haku ja jatketaan niin kauan kunnes on tultu maaliin.

Syklit ovat tässä menetelmässä sekä mahdollisia että yleisiä, joten ongelmaa on pyritty ratkaisemaan lisäämällä niin kutsuttua kohinaa etäisyysheuristiikkaan joka kerta kun yhteentörmäys havaitaan~\cite{silver05}. Jos siis jatkuvasti kohdataan esteitä jossakin solmussa tai jollakin alueella, niin algoritmin laskeman kustannuksen sinne etenemisestä pitäisi ennenpitkää nousta niin suureksi, että toimija hakeutuu ongelma-alueen ympäri tai etsii kokonaan uuden reitin.

Tällainen lähestymistapa johtaa ruuhkatilanteissa helposti oudolta näyttävään poukkoiluun, ja sen myötä prosessoriajan hävikkiin laskettaessa reitti jokaisen yhteentörmäyksen yhteydessä uudestaan.


\subsection{Cooperative A* (CA*)}

CA* pyrkii estämään yhteentörmäykset ennalta ottamalla aikaulottuvuuden huomioon reittejä suunniteltaessa. Jokaiselle toimijalle lasketaan reitti A*-algoritmilla ja suunnitellun reitin solut merkitään taulukkoon, esimerkiksi kolmiulotteiseen hajautustauluun, jossa kaksi ensimmäistä alkiota merkitsevät x- ja y-koordinaatteja, ja kolmas alkio aikaa milloin kyseinen solmu on tämän toimijan käytössä. Nyt seuraavien toimijoiden reittejä laskettaessa voidaan verrata suunniteltuja askeleita edellämainittuun taulukkoon ja odottamalla havaituissa törmäystilanteissa halutun reittisolmun vapautumista.

Tämän algoritmin heikkoutena on kyvyttömyys ratkaista joitakin verrattaen yksinkertaisia tilanteita. Kuvassa \ref{meeting_conflict} nähdään tilanne, missä toimijat S1 ja S2 pyrkivät vastaavasti maaleihin G1 ja G2. Intuitiivisesti nähdään, että jommankumman toimijan olisi mahdollista joko väistää sivulle tai nämä voisivat vaihtaa paikkoja kohdatessaan ja jatkaa sitten määränpäihinsä. Perusmuotoinen CA* ei kuitenkaan pysty tällaiseen ratkaisuun, sillä algoritmissa ei ole tällaista toiminnallisuutta.\newline

\begin{figure}
\captionsetup{width=.65\linewidth}
\includegraphics{meeting_conflict}
\centering
\caption{Esimerkki kohtaamis-ongelmasta, jossa toimijat S1 ja S2 voivat päästä maalisolmuihin G1 ja G2 vain jos jompikumpi väistää sivulle.}
\label{meeting_conflict}
\end{figure}

\subsection{Hierarchical Cooperative A* (HCA*)}

R.C.Holte ja kumppanit esittelivät vuonna 1996 hierarkkisen A*-reitinetsintä\-algoritmin HA*~\cite{holte96} ratkaisemaan CA*-algoritmin ongelmia. Siinä varsinaisen topologian rinnalla käytetään toista, abstraktia, topologiaa auttamaan A*-agoritmia löytämään kohteeseen. Alkuperäisen topologian solmut ryhmitetään halutun abstraktioetäisyyden perusteella isommiksi abstraktiosolmuiksi, ja tätä jatketaan rekursiivisesti niin kauan, kunnes koko topologiasta on muodostettu yksittäinen abstraktiosolmu. Varsinaisen topologian rinnalla on nyt siis monitasoinen abstraktiohierarkia, jonka alimmalla tasolla on alkuperäinen topologia. Tätä monitasoista hierarkiaa käytetään heuristiikan apuna ja liikkumalla siinä tasolta toiselle sen mukaan miten tarkkaa jakoa esimerkiksi esteiden ympärillä tarvitaan, ja käyttämällä sen antamia etäisyyksiä reitinhakualgoritmin apuna. Etäisyydet kohteeseen lasketaan vain tarvittaessa~\cite{silver05}. [aukaisu]\newline

HCA* eli hierarkkinen yhteistoiminnallinen A*-reitinetsintäalgoritmi puolestaan käyttää yksinkertaistettua hierarkiaa, joka koostuu vain yhdestä topologian kaksiulotteisesta abstraktiosta jättäen huomiotta niin aikaulottuvuuden, solmujen varaustaulun, kuin muut toimijat. Kuvassa 2 nähdään esimerkki topologian abstraktiosta, missä vasemmalla oleva ruudukko on mallinnettu graafiksi jakamalla se isommiksi abstraktiosolmuiksi (siniset kehykset). Kirjaimet S ja G viittaavat lähtö- ja maalisolmuihin. Oikeanpuoleisessa kuvaan on puolestaan merkitty punaisella jokaisen abstraktiosolmun sisällä olevat solmut ja niitä yhdistävät kaaret. Kaaren vierellä oleva luku tarkoittaa kaaren painoa, eli kuinka suuri hinta kaaren kulkemisella on.\newline

Kun reitti on laskettava uudelleen esimerkiksi jonkun toisen toimijan tullessa eteen, pyritään säästämään resursseja käyttämällä käänteistä jatkettavaa A*-hakua RRA* (Reverse Resumable A*) abstraktiotasolla. Siinä missä alkuperäinen reitti haettiin lähtöpisteestä maaliin, RRA* etsii reitin maalista haluttuun solmuun, kuten toimijaa lähimpään abstraktiotason solmuun~\cite{silver05}. Mikäli tässä vaiheessa optimaalisen reitin varrella on muita toimijoita, tulee lasketusta reitistä näiden väistämisen vuoksi luonnollisesti pidempi, aivan kuten alkuperäisen reitinhaunkin suhteen.\newline

Ongelmana tämän algoritmin käytössä on reitinhaun lopettamisen määritteleminen, sillä vaikka jokin toimija olisi jo tullut päämääräänsä, sen täytyy mahdollisesti vielä väistää jotain toista toimijaa ja hakeutua tämän jälkeen uudestaan maaliin~\cite{botea13}. Niinikään toimijoiden vuorojärjestyksellä on väliä: Staattinen vuorottelu voi johtaa siihen, ettei reittiä maaliin koskaan löydetä joidenkin toimijoiden sulkiessa toisiltaan tien. Tämä voidaan välttää antamalla toimijoille erilaiset prioriteetit jo alun alkaen, tai sitten sitten korkeampi prioriteetti voidaan antaa halutuille toimijoille vuorotellen lyhyeksi aikaa~\cite{silver05}. Tässä, kuten aiemmissakin yhteistoiminnallisissa reitinhakualgoritmeissa, on resurssien käytön suhteen ongelmana potentiaalisesti turhaan tehty työ.\newline

\begin{figure}
\captionsetup{width=.65\linewidth}
\includegraphics[scale=0.75]{grid_hierarchy}
\centering
\caption{Vasemmalla olevasta ruudukosta on muodostettu hierarkiamallin mukainen abstraktio.}
\label{grid_hierarchy}
\end{figure}

\subsection{Windowed Hierarchical Cooperative A* (WHCA*)}

WHCA* eroaa HCA*:sta siinä, että abstraktiotasolla reitti lasketaan maaliin ast, mutta konkreettisen topologian tasolla reitinhaku on rajoitettu johonkin ennaltamääriteltyyn syvyyteen~\cite{silver05, botea13}. Kun reittiä on kuljettu johonkin ennaltamääriteltyyn raja-arvoon asti, esimerkiksi puolet aiemmin lasketusta reitistä, lasketaan uusi osittainen reitti ja niin edelleen. ”Windowed” tarkoittaa tässä siis aikaikkunaa tai kehystä, mihin asti konkreettinen reitti on nähtävillä ja mitä siirretään aina tarpeen mukaan. Resurssien käyttöä voidaan myös tasata antamalla toimijoille erikokoiset ikkunat, jolloin taakka reittien laskemisesta saadaan jakautumaan tasaisemmin. Kuten HCA*, myös WHCA* hyödyntää käänteistä jatkettavaa A*-hakua eli RRA*:ta. Näin voidaan hyödyntää edellisen ikkunan aikana tehtyä hakua, mikä toisaalta tarkoittaa toimijakohtaista kirjanpitoa läpikäydyistä solmuista.
Koska yksittäisiä toimijoita WHCA*-algoritmissa ei johdeta keskitetysti, vaan ne pyrkivät itsenäisesti etsimään lyhintä reittiä maaliin, tuloksena voi olla tarpeetonta törmäilyä tilanteessa missä muuten olisi runsaasti tilaa lähettyvillä~\cite{sharon15}.

\subsection{Conflict-Based Search (CBS)}

Rinnakkaisen reitinhaun optimoimiseen pyrkivä CBS-algoritmi~\cite{sharon15} käyttää kaksitasoista lähestymistapaa, missä ensin käydään läpi ylemmän tason binääristä rajoituspuuta (constraint tree). Rajoituspuun jokaisessa solmussa on joukko rajoitteita (tieto siitä milloin joku topologian solmu on jonkun toimijan varaama), jotka kuuluvat jollekin yksittäiselle toimijalle. Toiseksi rajoituspuun solmuihin on myös talletettu joukko alemmalta tasolta saatuja reittejä, yksi jokaista toimijaa kohti, joiden tulee olla vapaita tiedetyistä yhteentörmäyksistä. Kolmanneksi niissä on myös yhteenlaskettu solmun reittikustannus, joka koostuu yksittäisen toimijan koko siihenastisen polun kustannuksesta. Rajoituspuu on järjestetty reittikustannuksen mukaan.

Alemmalla tasolla puolestaan voidaan käyttää tavanomaista yhden toimijan reitinhakualgoritmia kuten A* hyödyntäen samalla ylemmältä tasolta saatua tietoa siitä, missä ja milloin on odotettavissa yhteentörmäys jonkun toisen toimijan kanssa. Mikäli kaikesta huolimatta alemmalla tasolla havaitaan yhteentörmäyksiä, päivitetään ylemmän tason rajoituspuuta vastaavasti laajentamalla rajoituspuuta lisäämällä siihen solmuja. Tämän jälkeen tehdään uusi alemman tason haku ja toistetaan edellinen vaihe tarvittaessa.
\newline

\begin{algorithm}
\caption{ICBS-algoritmin ylempi taso}
\label{alg_icbs}
\begin{algorithmic}[1]
\State\textbf{Main(MAPF problem} instance\textbf{)}
	\State\indent Init $R$ with low-level paths for the individual agents
	\State\indent insert $R$ into OPEN
	\State\indent\textbf{while} OPEN $not$ $empty$ \textbf{do}
		\State\indent\indent $N\leftarrow$ best node from OPEN \textit{// lowest solution cost}
		\State\indent\indent Simulate the paths in $N$ and find all conflicts
		\State\indent\indent\textbf{if} $N$ \textit{has no conflict} \textbf{then}
		\State\indent\indent\indent\textbf{return} $N.solution$ \textit{// N is goal}
		\State\indent\indent $C\leftarrow$ find-cardinal/semi-cardinal-conflict($N$) \textit{// (PC)}
		\State\indent\indent\textbf{if} \textit{C is not cardinal} \textbf{then}
			\State\indent\indent\indent\textbf{if} \textit{Find-bypass(N, C)} \textbf{then} \textit{// (BP)}
				\State\indent\indent\indent\indent Continue
		\State\indent\indent\textbf{if} \textit{should-merge($a_i$, $a_j$)} \textbf{then} \textit{// Optional, MA-CBS:}
			\State\indent\indent\indent $a_{ij}$ = merge($a_i$, $a_j$)
			\State\indent\indent\indent\textbf{if} \textit{MR active} \textbf{then} \textit{// (MR)}
				\State\indent\indent\indent\indent Restart search
			\State\indent\indent\indent Update N.constraints()
			\State\indent\indent\indent Update N.solution by invoking low-level($a_{ij}$)
			\State\indent\indent\indent Insert N back into OPEN
			\State\indent\indent\indent continue \textit{// go back to the while statement}
		\State\indent\indent\textbf{foreach} \textit{agent $a_i$ in C} \textbf{do}
			\State\indent\indent\indent $A\leftarrow$ Generate Child($N$, (\textit{$a_i$, s, t}))
			\State\indent\indent\indent Insert $A$ into OPEN
\newline
\State\textbf{Generate Child(Node $N$, Constraint $C$ =} \textit{($a_i$, s, t)}\textbf{)}
\State\indent$A.constraints\leftarrow$ $N.constraints$ + \textit{($a_i$, s, t)}
\State\indent$A.solution\leftarrow N.solution$
\State\indent Update $A.solution$ by invoking \textit{low level}($a_i$)
\State\indent$A.cost\leftarrow$ \textit{SIC}($A.solution$)
\State\indent\textbf{return} $A$

\end{algorithmic}
\end{algorithm}


\section{Muut rinnakkaisen reitinhaun algoritmit}


\subsection{Increasing Cost Tree Search}

Vuonna 2012 julkaistu ICTS-algoritmi on kaksitasoista hierarkiaa hyödyntävä algoritmi~\cite{sharon2013}. Hierarkian ylemmällä tasolla käydään läpi puuta nimeltä \textit{increasing cost tree}. Se muodostuu solmuista, joista jokaisessa oleva taulukko $[C_1,...,C_k]$ edustaa kaikkia niitä mahdollisia reittiratkaisuja, missä toimijoiden reittien hinta on täsmälleen taulukkoon niitä vastaaville paikoille generoitu luku. Toisin sanoen toimijan $a_i$ reittikustannus löytyy taulukon kohdasta $C_i$.

Kuvassa \ref{ict} on havainnollistettu tällaisen puun rakennetta kolmen toimijan tapauksessa. Jokaisessa puun solmussa on kolme lukua, jotka siis edustavat näiden kolmen toimijan etäisyyttä maaliin solmussa pidettyjen reittiratkaisujen osalta. Juurisolmun lukemat ovat toimijoiden suorimmat mahdolliset etäisyydet maaliin, eli tilanne missä maaleihin voitaisiin kulkea välittämättä lainkaan muista toimijoista. Tässä esimerkissä jokaisen kolmesta toimijasta laskennallinen etäisyys maaliin on 10. Juurisolmulle ja jokaiselle solmulle sittemmin lisätään toimijoiden määrää vastaava määrä lapsisolmuja. Näihin lapsisolmuihin puolestaan lisätään siinä oleville toimijoille jokaiselle vuorollaan jokin lukuarvo (tässä 1) edustamaan pidempää reittiä. Toisen rivin ensimmäisessä solmussa on siis ensimmäinen toimija saanut arvon 11, toisessa solmussa keskimmäinen ja kolmannessa viimeinen.

ICT-puuta läpikäytäessä jokaisen solmun kohdalla kutsutaan alemman tason rutiinia tarkistamaan josko solmun määrittämä reittiyhdistelmä on löytynyt. Eli aluksi kokeillaan onko juurisolmun etäisyyksillä löydettävissä reitit kaikille toimijoille ja jos ei, siirrytään puussa alaspäin. Mitä alemmas puussa siis mennään, sitä suurempi on solmuissa olevien reittien hintojen summa.  Puuta käydään läpi leveyssuuntaisella haulla juuresta lähtien, joten ensimmäinen löydetty toteutettavissa oleva reittiratkaisu on myös väistämättä halvin.

Jokaista ICT-solmua tutkittaessa suoritetaan siis reittivertailu alemmalla hierarkiatasolla. Tämä tapahtuu käymällä läpi kunkin toimijan kaikki sellaiset reitit, joiden enimmäishinta on kyseiselle toimijalle ICT-solmussa asetettu arvo, ja vertailemalla näitä keskenään kunnes tuloksena on joukko ristiriidattomia reittejä. Koska eri reittejä voi olla hyvinkin suuri määrä, niiden käsittelemiseen on kehitetty oma algoritminsa, \textit{multi-value decision diagram} (MDD). Varsinaisten reittien muodostamiseen konkreettisessa topologiassa voidaan käyttää sopivaksi katsottua yhden toimijan reitinhakualgoritmia.

\begin{figure}
\captionsetup{width=.65\linewidth}
\includegraphics[scale=1]{ict}
\centering
\caption{Increasing Cost Tree kolmella toimijalla~\cite{sharon15}.}
\label{ict}
\end{figure}


\begin{algorithm}
\caption{Increasing Cost Tree}
\label{alg_icts}
\begin{algorithmic}[1]
\State\textbf{Input:} \emph{(k, n)} MAPF
\State Build the root of the ICT
\State\textbf{foreach} \emph{ICT node in a breadth-first manner} \textbf{do}
\State\indent\textbf{foreach} \emph{agent $a_i$} \textbf{do}
\State\indent\indent Build the corresponding $MDD_i$
\State\indent\textbf{[}\indent\textbf{//optional}
\State\indent\textbf{foreach} \emph{pair (triple) of agents} \textbf{do}
\State\indent\indent Perform node-pruning
\State\indent\indent\textbf{if} \emph{node-pruning failed} \textbf{then}
\State\indent\indent\indent\textbf{Break} \emph{//Conflict found. Next ICT node}
\State\indent\textbf{]}
\State\indent Search the $k$-agent MDD search space \emph{// low-level search}
\State\indent\textbf{if} \emph{goal node was found} \textbf{then}
\State\indent\indent\textbf{return} Solution
\end{algorithmic}
\end{algorithm}

\subsection{Tree-based agent swapping strategy (TASS)}

Tämä vuoden 2011 algoritmi hyödyntää graafien sijaan puurakenteita ja olemassaolevien graafien konvertoimiseen onkin kehittäjien toimesta luotu \textit{Graph-to-Tree Decomposition (GTD)}-algoritmeja. TASS on kehitetty erityisesti tilanteisiin, joissa vapaata liikkumatilaa on hyvin vähän.
TASS:n toimintaperiaatteena on siis topologian käsittely puuna, jossa siirtymät solmujen välillä on sallittu molempiin suuntiin. Puiden rakenteesta johtuen risteyksiä (tai haaroja) käytetään hyväksi toimijoiden uudelleenjärjestämisessä silloin, kun toimijat ovat toistensa tiellä. Tämä on havainnollistettu kuvassa \ref{tass}. Alkiot $u$ ja $v$ eivät voi tässä algoritmissa vaihtaa paikkaa päikseen, vaan ne on uudelleenjärjestettävä tekemällä tilaa lähimpään risteyssolmuun ja sen naapureihin, siirrettävä alkiot risteyksen yli uudelleenjärjestämistä varten, ja sitten palautettava lähtötilanne muilta osin ennalleen.
Suurempi haarautuvuus nopeuttaa algoritmin toimintaa~\cite{khorshid2011polynomial}.


\begin{figure}
\captionsetup{width=1\linewidth}
\includegraphics[scale=0.45]{tass}
\centering
\caption{Haarautuman hyväksikäyttö uudelleenjärjestämisessä TASS-algoritmilla~\cite{khorshid2011polynomial}.}
\label{tass}
\end{figure}

\subsection{Push and Swap}

Push and Swap edustaa rinnakkaisen reitinhaun uutta sukupolvea (2011) ja on verrattaen yksinkertainen toimintaperiaatteeltaan. Nimensä mukaisesti algoritmissa on kaksi keskeistä operaatiota, \textit{Push} ja \textit{Swap}, sekä kaksi apuoperaatiota, \textit{Clear} ja \textit{Resolve}. Toimijoiden suoritusjärjestys määräytyy jonkin ennaltamääritellyn prioriteettijonon perusteella~\cite{luna2011push}.

Push-operaatio liikuttaa toimijaa $r$ kohti maalia. Mikäli maaliin ei päästä jonkun toisen toimijan $s$ tukkiessa tien ja ollessa alempi prioriteetiltaan, Push yrittää työntää tiellä olevat toimijat pois edestä vapaisiin solmuihin ja jatkaa sitten maaliin. Mikäli vapaata tilaa ei ole, työntäminen vaatisi $r$:n itsensä siirtymistä, työnnettävällä toimijalla on korkeampi prioriteetti, tai pitäisi työntää jo omiin maaleihinsa löytäneitä toimijoita sivuun, otetaan Swap-operaatio käyttöön.

Swap siirtää sekä $r$:n että $s$:n lähimpään sellaiseen paikkaan graafissa, jossa on riittävästi tilaa paikkojen vaihtamiseen, kuten nähdään kuvassa \ref{push_swap}. Seuraavaksi suoritetaan Clear-operaatio, jolla pyritään tyhjentämään kohdesolmun viereiset solmut työntämällä niissä olevat toimijat muihin vapaisiin solmuihin. Esimerkkikuvassamme kohdesolmu on keskellä sijaitseva $v$, jonka vierellä on kaksi tyhjää solmua joihin sekä $r$ että $s$ voivat väistää. Jos Clear onnistui, palautetaan mahdollisesti edestä työnnetyt toimijat takaisin alkuperäisille paikoilleen. Toisin kuin Push, Swap voi siirtää korkeamman prioriteetin omaavia, sekä omiin maaleihinsa jo päässeitä toimijoita paikoiltaan. Tämä voi johtaa siihen, että $r$ on nyt jonkun muun toimijan $t$ maalisolmussa. Tilanne ratkaistaan Resolve-operaatiolla: Ensin $r$ yritetään työntää edelleen kohti maaliaan. Mikäli tämä onnistuu, voidaan $t$ palauttaa maalisolmuunsa. Mikäli ei, Swap:ia kutsutaan $r$:lle uudestaan. Jos tämä ei onnistu, suoritetaan Swap $t$:lle~\cite{de2013push}.

Tässä algoritmissa vaivaa kuitenkin joukko ongelmia: Niin kutsuttujen \textit{monikulmiograafien} (polygon graph) tapauksessa algoritmi voi jäädä silmukkaan. Kyseiset graafit ovat määritelmällisesti sellaisia, että jokaisella solmulla on korkeintaan kaksi naapuria. Swap voi myös johtaa laittomaan tilaan (illegal state), mikäli sen toteuttaminen saa aikaan muita Swap-operaatioita ahtaassa tilassa, jolloin algoritmin rakenteesta johtuen operaation ennakkoehdot eivät tietyissä olosuhteissa enää päde. Graafissa esiintyvä kannas (isthmus), eli osio missä on peräkkäisiä solmuja joilla on vain kaksi naapuria, voi johtaa lukkiutumiseen. Clear-operaatio ei osaa käsitellä tilannetta, missä siirtämällä tiellä olevaa toimijaa kahdesti saataisiin riittävästi tilaa paikanvaihtoa varten.

\begin{figure}
\captionsetup{width=1\linewidth}
\includegraphics[scale=1]{push_swap2}
\centering
\caption{Push and Swap-algoritmi: Alkioiden $r$ ja $s$ paikat vaihdetaan Swap-operaatiolla~\cite{luna2011push}.}
\label{push_swap}
\end{figure}

\subsection{Push and Rotate}

Push and Rotate vuodelta 2013 on Push and Swap-algoritmin jatkokehitetty versio, joka pyrkii paikkaamaan siinä havaittuja puutteita: Monikulmiograafien ongelma on ratkaistu priorisoimalla reitinhaussa sellaisia reittejä, joiden varrella ei ole lainkaan jo maaliin päässeitä toimijoita. Clear-operaation toimintaa on laajennettu ja niin kutsuttu \textit{kannasongelma} on ratkaistu jakamalla kokonaisuus eri tavalla priorisoituihin aliongelmiin. Niinikään tekijöiden \textit{recursive resolve}:ksi nimeämä ongelma ratkaistaan uudella Rotate-operaatiolla~\cite{de2013push}.

\section{Yhteenveto}

Reitinhaku ja sen erityistapaus rinnakkainen reitinhaku pysyvät avoimina ongelmina vuosikymmeniä kestäneestä tutkimuksesta huolimatta. Syynä tähän on ensisijaisesti algoritmien vaihteleva soveltuvuus eri tarpeisiin, ja toisaalta kasvaneet tehokkuusvaatimukset etenkin tietokonepelien saralla. Kehitys on toisaalta kulkenut kohti algoritmeja, jotka hyödyntävät useampitasoista hierarkiaa vähentämään laskentaresurssien tarvetta abstraktion kautta, sekä toisaalta kohti perinteistä poikkeavia lähestymistapoja, kuten \textit{Push and Swap} tai \textit{Push and Rotate}.
Mikäli liikkumatila ei ole minimissään ja toimijoita on paljon, ovat \textit{erotetut} algoritmit, joissa toimijoita käsitellään itsenäisinä tekijöinä, yleensä tehokkaampia ratkaisuja. Ne eivät tavallisesti kuitenkaan johda yhtä optimaalisiin reittivalintoihin kuin \textit{yhdistetyt} algoritmit, joissa toimijoita käsitellään kokonaisuuden osina ja joiden reittejä suunnitellaan alusta asti muita toimijoita silmälläpitäen~\cite{luna2011push}.
Ohjelmoijan vastuulle jääkin pohtia topologiaa, toimijoiden lukumäärää ja laskentanopeuden tarvetta sopivaa reitinhakualgoritmia valitessaan. Kaikkiin tilanteisiin sopivaa yleisalgoritmia ei ole olemassa, eikä sellaista kenties ole mahdollista toteuttaakaan.


% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\pagebreak

\bibliographystyle{babplain-lf}
%\bibliographystyle{unsrt}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
