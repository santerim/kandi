% --- Template for thesis / report with tktltiki2 class ---
% 
% last updated 2013/02/15 for tkltiki2 v1.02

\documentclass[finnish]{tktltiki2}

% tktltiki2 automatically loads babel, so you can simply
% give the language parameter (e.g. finnish, swedish, english, british) as
% a parameter for the class: \documentclass[finnish]{tktltiki2}.
% The information on title and abstract is generated automatically depending on
% the language, see below if you need to change any of these manually.
% 
% Class options:
% - grading                 -- Print labels for grading information on the front page.
% - disablelastpagecounter  -- Disables the automatic generation of page number information
%                              in the abstract. See also \numberofpagesinformation{} command below.
%
% The class also respects the following options of article class:
%   10pt, 11pt, 12pt, final, draft, oneside, twoside,
%   openright, openany, onecolumn, twocolumn, leqno, fleqn
%
% The default font size is 11pt. The paper size used is A4, other sizes are not supported.
%
% rubber: module pdftex

% --- General packages ---

\usepackage{courier}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{microtype}
\usepackage{amsfonts,amsmath,amssymb,amsthm,booktabs,color,enumitem,graphicx}
\usepackage[pdftex,hidelinks]{hyperref}

% omat
\usepackage{graphicx}
\usepackage[font={small,it}]{caption}

% Automatically set the PDF metadata fields
\makeatletter
\AtBeginDocument{\hypersetup{pdftitle = {\@title}, pdfauthor = {\@author}}}
\makeatother

% --- Language-related settings ---
%
% these should be modified according to your language

% babelbib for non-english bibliography using bibtex
\usepackage[fixlanguage]{babelbib}
\selectbiblanguage{finnish}

% add bibliography to the table of contents
\usepackage[nottoc]{tocbibind}
% tocbibind renames the bibliography, use the following to change it back
\settocbibname{Lähteet}

% paketit algoritmien esittämistä varten
\usepackage{algorithm}
\usepackage{algpseudocode}

% --- Theorem environment definitions ---

\newtheorem{lau}{Lause}
\newtheorem{lem}[lau]{Lemma}
\newtheorem{kor}[lau]{Korollaari}

\theoremstyle{definition}
\newtheorem{maar}[lau]{Määritelmä}
\newtheorem{ong}{Ongelma}
\newtheorem{alg}[lau]{Algoritmi}
\newtheorem{esim}[lau]{Esimerkki}

\theoremstyle{remark}
\newtheorem*{huom}{Huomautus}


% --- tktltiki2 options ---
%
% The following commands define the information used to generate title and
% abstract pages. The following entries should be always specified:

\title{Rinnakkainen reitinhaku}
\author{Santeri Martikainen}
\date{\today}
\level{Kandidaatintutkielma}
\abstract{Tiivistelmä.}

% The following can be used to specify keywords and classification of the paper:

\keywords{avainsana 1, avainsana 2, avainsana 3}

% classification according to ACM Computing Classification System (http://www.acm.org/about/class/)
% This is probably mostly relevant for computer scientists
% uncomment the following; contents of \classification will be printed under the abstract with a title
% "ACM Computing Classification System (CCS):"
% \classification{}

% If the automatic page number counting is not working as desired in your case,
% uncomment the following to manually set the number of pages displayed in the abstract page:
%
% \numberofpagesinformation{16 sivua + 10 sivua liitteissä}
%
% If you are not a computer scientist, you will want to uncomment the following by hand and specify
% your department, faculty and subject by hand:
%
% \faculty{Matemaattis-luonnontieteellinen}
% \department{Tietojenkäsittelytieteen laitos}
% \subject{Tietojenkäsittelytiede}
%
% If you are not from the University of Helsinki, then you will most likely want to set these also:
%
% \university{Helsingin Yliopisto}
% \universitylong{HELSINGIN YLIOPISTO --- HELSINGFORS UNIVERSITET --- UNIVERSITY OF HELSINKI} % displayed on the top of the abstract page
% \city{Helsinki}
%


\begin{document}

% --- Front matter ---

\frontmatter      % roman page numbering for front matter

\maketitle        % title page
\makeabstract     % abstract page

\tableofcontents  % table of contents

% --- Main matter ---

\mainmatter       % clear page, start arabic page numbering

\section{Johdanto}

Tässä tutkielmassa keskitytään tarkastelemaan monen yhtaikaisen toimijan (agent) reitinhakuongelmaa ja sen ratkaisemiseksi kehitettyjä algoritmeja. Reitinhaussa on pohjimmiltaan kyse mahdollisimman suoran ja nopean polun löytämisestä kahden pisteen välillä jossakin topologiassa. Topologia, eli kenttä tai alue, voi olla reaalimaailmassa, kuten tieverkosto autonavigaattorin reitinhaussa tai vaikkapa kokoonpanolinjan robotin käytettävissä oleva liikkumatila. Topologia voi myös olla täysin virtuaalinen, kuten tietokonepelien pelimaailmat. Muita käyttökohteita ovat muun muassa liikenteen ja väkijoukkojen mallintaminen, poliisin ja pelastustoimen tehtävät, sekä tietoliikenneverkot. Käyttökohteesta riippumatta topologia, jossa reittejä etsitään, on mallinnettava tietorakenteiksi sen läpikäyntiä varten.

Oli reitinhaun sovelluskohde mikä hyvänsä, on selvää että mikäli varsinaista reitinhakua tarvitaan, ei reitin löytäminen ainakaan jokaisella suorituskerralla voi olla täysin suoraviivaista ja triviaalia. Jos se olisi, asia voitaisiin ratkaista yksinkertaisesti laskemalla lyhin etäisyys mitä pitkin liikkua suoraan kohteeseen ja toimia sen mukaan. Kysymys on siis reittien löytämisestä tietyin reunaehdoin. Jos ajattelemme esimerkiksi navigaattoria käyttävää autoilijaa, tämä haluaa kaikella todennäköisyydellä ajaa määränpäähänsä lyhintä reittiä teitä pitkin oikaisematta yhdenkään metsän tai järven lävitse.

% Write some science here.

% Esimerkkilause ja lähdeviite~\cite{esimerkki}.

\section{Reitinhaku}

Reitinhaun toteuttaminen jakaantuu kahteen vaiheeseen: Toimintaympäristöstä tai topologiasta muodostetaan ensin yksinkertaistettu malli, minkä jälkeen sitä käydään läpi jollakin algoritmilla halutun reitin löytämiseksi. Algoritmia ohjaa heuristiikkafunktio jolla arvioidaan etäisyyttä kohteeseen ja voidaan siten vertailla eri reittivaihtoehtojen keskinäistä paremmuutta. Jonkin reitin paremmuuteen muihin nähden voi vaikuttaa pituuden lisäksi myös sen nopeus.

Mallinnettavasta ympäristöstä riippumatta kyseessä on käytännössä verkko \texttt{G=(V,E)}, missä \texttt{V} (vertex) on joukko solmuja ja \texttt{E} (edge) joukko solmuja yhdistäviä kaaria. Liikkuminen voi esimerkiksi tapahtua solmusta toiseen, tai sitten solmut voivat edustaa kiintopisteitä joiden läheisyydessä voidaan liikkua ilman erillistä reitinhakua. Solmut voivat myös toimia esteinä, jolloin niihin liikkuminen on estetty. Tämä voi myös olla vain solmun väliaikainen tila esimerkiksi jonkun toisen toimijan ollessa liikkumisen tiellä. Verkko voi siis olla dynaaminen, eli sen rakenne saattaa muuttua kesken reittien läpikäymisen, mikä asettaa omat haasteensa reitinhaulle~\cite{botea13, algfoor15}.

Edellämainittujen esteiden ja muuttuvan toimintaympäristön lisäksi reitinhaun keskeisiä ongelmia on resurssien käyttö. Mitä laajemmassa topologiassa reitinhaku suoritetaan, sitä enemmän laskentaresursseja (muistia, prosessoriaikaa) siihen menee. Joissakin tilanteissa voidaan tyytyä osittaiseen reitinhakuun, eli reittiä ei lasketa loppuun asti, vaan ainoastaan johonkin tiettyyn ennaltamäärättyyn pisteeseen ja uusi reitinhaku tehdään kun jokin välietappi on saavutettu. Tässä on luonnollisesti varmistuttava siitä, että valittuun suuntaan lähteminen todella mahdollistaa perille pääsemisen. Toinen lähestymistapa on kaikkien mahdollisten reittien laskeminen ennakkoon, jolloin haluttu reitti kahden sijainnin välillä yksinkertaisesti haetaan taulukosta tarvittaessa. Tämän menetelmän heikkoutena on, että kyseisestä taulukosta saattaa tulla niin suuri, että varsinainen reitinhaku on nopeampi toteuttaa. Niinikään se vaatii käytännössä mainitun taulukon pitämistä jatkuvasti muistissa.

%pelimaailman tyypillinen tilanne tähän

%Tyypillisesti kenttä muodostetaan soluista (cell), joista toisinaan käytetään myös nimitystä laatta (tile). Solut ovat käytännössä monikulmioita, usein joko kolmioita, neliöitä tai kuusikulmioita. Edellämainitut muodot ovat ainoat monikulmiot, joita yhdistelemällä voidaan jokin alue kattaa yhtenäisesti ilman väliin jääviä aukkoja, mikäli kenttä halutaan mallintaa keskenään samankokoisilla soluilla. Mallinnus voidaan tehdä myös vaihtelevan kokoisilla monikulmioilla. Solut joissa kentällä voidaan liikkua muodostavat reitinhaussa käytettävän verkon (graph) solmut (vertex)~\cite{botea13, cui11}.

Reitinhaun standardialgoritmi on jo pitkään ollut A* (eli A-star tai A-tähti), joka perustuu niin kutsuttuun Dijkstran algoritmiin, ja josta on kehitetty lukuisia eri variantteja eri toimintaympäristöjä ja tarpeita silmälläpitäen. Sen etuja on, että se pystyy varmuudella löytämään reitin kohteeseen, jos sellainen on ylipäätään olemassa. Niinikään se antaa parhaan mahdollisen reitin useista vaihtoehdoista, mikäli sen heuristiikkafunktio ei yliarvioi etäisyyttä kohteeseen~\cite{cui11, sharon15, botea04}. Tärkeisiin heuristisiin algoritmeihin kuuluvat myös iteratiivinen syvyys-A* (iterative-deepening-A*, IDA*) ja syvyyssuuntainen haarautuva rajattu (depth-first branch-and-bound, DFBnB)~\cite{felner2004additive}.

\subsection{Dijkstran algoritmi}

Edsger Dijkstra esitteli 1959 algoritmin, joka etsii lyhimmät reitit kaikkien graafissa esiintyvien solmujen välillä~\cite{dijkstra1959numerische}. Kyseessä on leveyssuuntaista hakua toteuttava algoritmi. Tämä tarkoittaa, että ensin tutkitaan kaikki lähtösolmun naapurit, sitten naapureiden naapurit ja niin edelleen, kunnes joko kaikki solmut on käyty läpi, tai jokin algoritmille asetettu pysähtymisehto on täyttynyt. Tällainen ehto voi olla esimerkiksi reitin löytyminen kahden määritellyn solmun välillä.

Kuvassa \ref{dijkstra} nähdään miten viisisolmuisessa graafissa löydetään lyhyimmät reitit solmujen (ympyrät) välillä. Solmuja yhdistää joukko suunnattuja kaaria, joiden vieressä oleva luku kuvaa kaaren painoa, eli sen kulkemisen hintaa. Ainoastaan lähtösolmu $s$ on tässä vaiheessa saanut numeroarvon, joka kuvaa sen etäisyyttä lähtösolmuun. Kohdassa b on tutkittu ne solmut joihin edellisestä solmusta pääsee, sekä asetettu niille etäisyysarvot. C-kohdassa on jälleen jatkettu yksi askel eteenpäin, mutta on huomattava kuinka solmun $t$ arvo on nyt muuttunut b-kohtaan verrattuna. Tämä johtuu siitä, että $y$-solmun kautta kulkeva reitti on havaittu lyhyemmäksi kuin suora yhteys $s$- ja $t$-solmujen välillä. Tätä jatketaan niin kauan kunnes koko graafi on käyty läpi ~\cite{dijkstra1959numerische, skiena1990dijkstra}.
Dijkstran algoritmia käytetään edelleen muun muassa joissakin tietoliikenneverkkojen reititysprotokollissa.

\begin{figure}
\captionsetup{width=\linewidth}
\includegraphics[width=\textwidth, keepaspectratio]{dijkstra}
\centering
\caption{Graafin läpikäynti Dijkstran algoritmilla}
\label{dijkstra}
\end{figure}

\subsection{A*-algoritmi}

Dijkstran algoritmiin perustuva A* toteuttaa niin sanottua paras ensin -tyyliä, jossa jokaisen solmun tai solun kohdalla pyritään ensiksi etenemään suoraan kohti maalia. Jos tiellä on jokin este, algoritmi pyrkii kiertämään sen. Tämä tapahtuu etenemällä valitsemalla tähänastisen reitin viereisistä soluista ne joista arvioidaan olevan lyhyin etäisyys maaliin. Tätä jatketaan kunnes joko päästään kohteeseen, tai selviää että reittiä ei ole. A* poikkeaa siis Dijkstran algoritmista hakeutumalla koko ajan maalin suuntaan, mikä tapahtuu heuristiikkafunktion avulla (algoritmi \ref{alg_astar}:n rivi 13).

Kaikille algoritmin käsittelemille solmuille lasketaan arvo kaavalla \begin{equation}\label{astarkaava}{f(n) = g(n)+h(n)}\end{equation} missä $g(n)$ on lyhin tunnettu reitti lähtösolmusta solmuun $n$ ja $h(n)$ on heuristinen arvio etäisyydestä maalisolmuun~\cite{sharon15, stout96}. Näin jokaisen läpikäydyn solmun kohdalla tiedetään sille lasketusta arvosta kuinka suoralla reitillä kohteeseen ollaan. Solmuille voidaan myös asettaa edellämainittuun kaavaan lisättävä arvo tekemään siihen siirtymisestä hintavampaa ja näin mallintaa hitaampaa kulkuyhteyttä kahden paikan välillä.

Kuvassa \ref{dijkstrab} on havainnollistettu Dijkstran algoritmin löytämä reitti yksinkertaisessa ruudukossa. Liikkuminen on rajoitettu niin sanottuun Manhattan -tyyliin, missä sallitut kulkusuunnat ovat neljä pääilmansuuntaa. Esteenä toimivat solmut on väritetty tummanharmaalla ja algoritmin läpikäymät solmut turkoosilla. Jälkimmäisen värisävyt kuvaavat laskennallista etäisyyttä vaaleanpunaiseen lähtösolmuun. Kuten kuvasta nähdään, Dijkstra käy läpi varsin suuren osan kentän solmuista, mutta löytää suorimman reitin violetilla merkittyyn kohteeseen.

Kuvassa \ref{astar} voidaan nähdä ero A*-algoritmin toimintaperiaatteessa. Nyt tutkittuja solmuja on paljon vähemmän heuristiikan ohjatessa läpikäynnin suuntaa. Vaikka reitit hieman poikkeavatkin toisistaan, ne ovat annettujen ennakkoehtojen valossa yhtä pitkiä.

\begin{figure}
\captionsetup{width=\linewidth}
\includegraphics[width=\textwidth, keepaspectratio]{dijkstrab}
\centering
\caption{Esteen kiertäminen Dijkstran algoritmilla}
\label{dijkstrab}
\end{figure}

\begin{figure}
\captionsetup{width=\linewidth}
\includegraphics[width=\textwidth, keepaspectratio]{astar}
\centering
\caption{Esteen kiertäminen A*-algoritmilla}
\label{astar}
\end{figure}

\begin{algorithm}
\caption{A*-algoritmin pseudokoodi}
\label{alg_astar}
\begin{algorithmic}[1]
	\Procedure{Astar}{startnode, goalnode}
	\State initialize the open list
	\State initialize the closed list
	\State put the starting node on the open list (you can leave its f at zero)
	\newline
	\While{the open list is not empty}
		\State find the node with the least f on the open list, call it 'q'
		\State pop q off the open list
		\State generate q's 8 successors and set their parents to q
		\For{each successor}
			\State \textbf{if} successor is the goal \textbf{then}
			\State \indent stop search
			\State successor.g = q.g + distance between successor and q
			\State successor.h = distance from goal to successor
			\State successor.f = successor.g + successor.h
			\State \textbf{if} a node with the same position as successor is in the OPEN \indent\indent \: list which has a lower f than successor \textbf{then}
			\State \indent skip this successor
			\State \textbf{if} a node with the same position as successor is in the CLOSED \indent\indent \: list which has a lower f than successor \textbf{then}
			\State \indent skip this successor
			\State otherwise, add the node to the open list
		\EndFor
		\State push q on the closed list
	\EndWhile
	\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsection{Puurakenteet}

\section{Rinnakkainen reitinhaku}

Rinnakkaisessa reitinhaussa on yleensä useita, joskus jopa satoja tai tuhansia, eri toimijoita. Kaikille näille on löydettävä reitit kohteisiinsa. Tällainen monen toimijan rinnakkainen reitinhaku (multi-agent pathfinding, MAPF) tuo yksittäisen toimijan reitinhakuun verrattuna uusia ongelmia. On ratkaistava muun muassa sallitaanko reittien risteäminen, voiko kaksi tai useampi toimijaa olla samaan aikaan samassa paikassa, tuleeko liikkumista porrastaa odottamalla että reitti edessä vapautuu ja tuleeko toimijan väistää ollessaan toisen tiellä~\cite{erdem13}. Näiden ongelmien ratkaisemiseen kehitetyistä algoritmeja useimmat hyödyntävät A*-algoritmia jollakin tapaa~\cite{sharon15}.

Mitä enemmän toimijoita tutkittavalla alueella on, sitä oleellisemmaksi muodostuu yhteentörmäyksien ja tahattoman reittien sulkemisen välttäminen. Yksi oleellinen ero lähestymistavoissa on käsitelläänkö toimijoita yhdistettynä (coupled) toimijana, vai toisistaan erotettuina (decoupled) toimijoina. Erotetussa menetelmässä reitit lasketaan jokaiselle toimijalle erikseen ja mahdolliset yhteentörmäykset ratkaistaan valitulla menettelyllä sikäli kuin niitä tapahtuu. Tämä menetelmä on tyypillinen tilanteille, joissa toimijoita on verrattaen paljon~\cite{sharon2013}. Yhdistetyssä menetelmässä kaikkia toimijoita käsitellään sen sijaan kokonaisuutena. Tämä voidaan toteuttaa esimerkiksi varaamalla graafin solmuja toimijoiden käyttöön siksi aikaa kun näiden odotetaan oman reitinhakunsa perusteella niissä olevan. Lukuisten toimijoiden yhtäaikainen huomioonottaminen luonnollisesti lisää ongelman monimutkaisuutta.

Yksi graafien ominaisuuksia on \textit{haarautuvuus} (branching). Tällä tarkoitetaan keskimääräistä lukumäärään naapurisolmuja, joihin jostakin graafin solmusta voidaan liikkua. Jos meillä on graafi, jonka haarautuvuus on $b$, niin erotetussa menetelmässä jokaisella toimijalla on $O(b+1)$ mahdollista liikettä, eli siirtymät toisiin solmuihin ja paikallaan odottaminen. Yhdistetyssä menetelmässä on sen sijaan joka askeleella otettava myös huomioon $k$ toimijaa, jolloin mahdollisia liikkeitä on $O(b+1)^k$. Tämä hidastaa reittien laskemista~\cite{sharon2013}.

Kuten edellä todettiin, useimmat rinnakkaisen reitinhaun ratkaisemiseen kehitetyt menetelmät ovat A*-pohjaisia. On myös kokonaan toisenlaisia lähestymistapoja, joilla pyritään pitämään alati kasvava laskentaresurssien tarve kurissa. 



\section{A*-pohjaiset rinnakkaisen reitinhaun algoritmit}

kuvaukset:\newline
Pattern Databases\newline
Independence detection (ID)\newline
Operator decomposition (OD)\newline
Enhanced partial expansion (EPE)
\subsection{Local Repair A* (LRA*)}

LRA* on yleistermi joukolle A*-pohjaisia algoritmeja, jotka jakavat saman toimintaperiaatteen: Jokainen toimija etsii reitin A*:lla ja seuraa sitä siihen asti kunnes siirtyminen seuraavaan solmuun saisi aikaan yhteentörmäyksen jonkun toisen toimijan kanssa, eli solmu johon pitäisi siirtyä on varattu. Tällöin tehdään uusi A*-haku ja jatketaan niin kauan kunnes on tultu maaliin.

Syklit ovat tässä menetelmässä sekä mahdollisia että yleisiä, joten ongelmaa on pyritty ratkaisemaan lisäämällä niin kutsuttua kohinaa etäisyysheuristiikkaan joka kerta kun yhteentörmäys havaitaan~\cite{silver05}. Jos siis jatkuvasti kohdataan esteitä jossakin solmussa tai jollakin alueella, niin algoritmin laskeman kustannuksen sinne etenemisestä pitäisi ennenpitkää nousta niin suureksi, että toimija hakeutuu ongelma-alueen ympäri tai etsii kokonaan uuden reitin.

Tällainen lähestymistapa johtaa ruuhkatilanteissa helposti oudolta näyttävään poukkoiluun, ja sen myötä prosessoriajan hävikkiin kun jokaisen yhteentörmäyksen yhteydessä reitti pitää laskea uudestaan.


\subsection{Cooperative A* (CA*)}

CA* pyrkii estämään yhteentörmäykset ennalta ottamalla aikaulottuvuuden huomioon reittejä suunniteltaessa. Jokaiselle toimijalle lasketaan reitti A*-algoritmilla ja suunnitellun reitin solut merkitään taulukkoon, esimerkiksi kolmiulotteiseen hajautustauluun, jossa kaksi ensimmäistä alkiota merkitsevät x- ja y-koordinaatteja, ja kolmas alkio aikaa milloin kyseinen solmu on tämän toimijan käytössä. Nyt seuraavien toimijoiden reittejä laskettaessa voidaan verrata suunniteltuja askeleita edellämainittuun taulukkoon ja odottamalla havaituissa törmäystilanteissa halutun reittisolmun vapautumista.

Tämän algoritmin heikkoutena on kyvyttömyys ratkaista joitakin verrattaen yksinkertaisia tilanteita. Kuvassa \ref{meeting_conflict} nähdään tilanne, missä toimijat S1 ja S2 pyrkivät vastaavasti maaleihin G1 ja G2. Intuitiivisesti nähdään, että jommankumman toimijan olisi mahdollista joko väistää sivulle tai nämä voisivat vaihtaa paikkoja kohdatessaan ja jatkaa sitten määränpäihinsä. Perusmuotoinen CA* ei kuitenkaan pysty tällaiseen ratkaisuun, sillä algoritmissa ei ole tällaista toiminnallisuutta.\newline

\begin{figure}
\captionsetup{width=.65\linewidth}
\includegraphics{meeting_conflict}
\centering
\caption{Esimerkki kohtaamis-ongelmasta, jossa toimijat S1 ja S2 voivat päästä maalisolmuihin G1 ja G2 vain jos jompikumpi väistää sivulle.}
\label{meeting_conflict}
\end{figure}

\subsection{Hierarchical Cooperative A* (HCA*)}

R.C.Holte ja kumppanit esittelivät vuonna 1996 hierarkkisen A*-reitinetsintä\-algoritmin HA*~\cite{holte96} ratkaisemaan CA*-algoritmin ongelmia. Siinä varsinaisen topologian rinnalla käytetään toista, abstraktia, topologiaa auttamaan A*-agoritmia löytämään kohteeseen. Alkuperäisen topologian solmut ryhmitetään halutun abstraktioetäisyyden perusteella isommiksi abstraktiosolmuiksi, ja tätä jatketaan rekursiivisesti niin kauan, kunnes koko topologiasta on muodostettu yksittäinen abstraktiosolmu. Varsinaisen topologian rinnalla on nyt siis monitasoinen abstraktiohierarkia, jonka alimmalla tasolla on alkuperäinen topologia. Tätä monitasoista hierarkiaa käytetään heuristiikan apuna ja liikkumalla siinä tasolta toiselle sen mukaan miten tarkkaa jakoa esimerkiksi esteiden ympärillä tarvitaan, ja käyttämällä sen antamia etäisyyksiä reitinhakualgoritmin apuna. Etäisyydet kohteeseen lasketaan vain tarvittaessa~\cite{silver05}. [aukaisu]\newline

HCA* eli hierarkkinen yhteistoiminnallinen A*-reitinetsintäalgoritmi puolestaan käyttää yksinkertaistettua hierarkiaa, joka koostuu vain yhdestä topologian kaksiulotteisesta abstraktiosta jättäen huomiotta niin aikaulottuvuuden, solmujen varaustaulun, kuin muut toimijat. Kuvassa 2 nähdään esimerkki topologian abstraktiosta, missä vasemmalla oleva ruudukko on mallinnettu graafiksi jakamalla se isommiksi abstraktiosolmuiksi (siniset kehykset). Kirjaimet S ja G viittaavat lähtö- ja maalisolmuihin. Oikeanpuoleisessa kuvaan on puolestaan merkitty punaisella jokaisen abstraktiosolmun sisällä olevat solmut ja niitä yhdistävät kaaret. Kaaren vierellä oleva luku tarkoittaa kaaren painoa, eli kuinka suuri hinta kaaren kulkemisella on.\newline

Kun reitti on laskettava uudelleen esimerkiksi jonkun toisen toimijan tullessa eteen, pyritään säästämään resursseja käyttämällä käänteistä jatkettavaa A*-hakua RRA* (Reverse Resumable A*) abstraktiotasolla. Siinä missä alkuperäinen reitti haettiin lähtöpisteestä maaliin, RRA* etsii reitin maalista haluttuun solmuun, kuten toimijaa lähimpään abstraktiotason solmuun~\cite{silver05}. Mikäli tässä vaiheessa optimaalisen reitin varrella on muita toimijoita, tulee lasketusta reitistä näiden väistämisen vuoksi luonnollisesti pidempi, aivan kuten alkuperäisen reitinhaunkin suhteen.\newline

Ongelmana tämän algoritmin käytössä on reitinhaun lopettamisen määritteleminen, sillä vaikka jokin toimija olisi jo tullut päämääräänsä, sen täytyy mahdollisesti vielä väistää jotain toista toimijaa ja hakeutua tämän jälkeen uudestaan maaliin~\cite{botea13}. Niinikään toimijoiden vuorojärjestyksellä on väliä: Staattinen vuorottelu voi johtaa siihen, ettei reittiä maaliin koskaan löydetä joidenkin toimijoiden sulkiessa toisiltaan tien. Tämä voidaan välttää antamalla toimijoille erilaiset prioriteetit jo alun alkaen, tai sitten sitten korkeampi prioriteetti voidaan antaa halutuille toimijoille vuorotellen lyhyeksi aikaa~\cite{silver05}. Tässä, kuten aiemmissakin yhteistoiminnallisissa reitinhakualgoritmeissa, on resurssien käytön suhteen ongelmana potentiaalisesti turhaan tehty työ.\newline

\begin{figure}
\captionsetup{width=.65\linewidth}
\includegraphics[scale=0.75]{grid_hierarchy}
\centering
\caption{Vasemmalla olevasta ruudukosta on muodostettu hierarkiamallin mukainen abstraktio.}
\end{figure}

\subsection{Windowed Hierarchical Cooperative A* (WHCA*)}

WHCA* eroaa HCA*:sta siinä, että konkreettisen topologian tasolla reittejä ei lasketa maaliin asti, vaan reitinhaku on rajoitettu johonkin ennaltamääriteltyyn syvyyteen. Jotta toimijat saadaan hakeutumaan varmasti oikeaan suuntaan, lasketaan reitti abstraktiotasolla sen sijaan maaliin asti~\cite{silver05, botea13}. Kun reittiä on kuljettu johonkin ennaltamääriteltyyn raja-arvoon asti, kuten puolet aiemmin lasketusta reitistä, lasketaan uusi osittainen reitti ja niin edelleen. ”Windowed” tarkoittaa tässä siis aikaikkunaa tai kehystä, mihin asti konkreettinen reitti on nähtävillä ja mitä siirretään aina tarpeen mukaan. Resurssien käyttöä voidaan myös tasata antamalla toimijoille erikokoiset ikkunat, niin että taakka reittien laskemisesta jakautuu mahdollisimman tasaisesti ajan suhteen. Kuten HCA*, myös WHCA* hyödyntää RRA*:ta ja hyödyntää edellisen ikkunan aikana tehtyä hakua, mikä luonnollisesti tarkoittaa toimijakohtaista kirjanpitoa läpikäydyistä solmuista.

\subsection{Hierarchical Pathfinding A* (HPA*)}



\subsection{Conflict-Based Search (CBS)}

Rinnakkaisen reitinhaun optimoimiseen pyrkivä CBS-algoritmi~\cite{sharon15} käyttää kaksitasoista lähestymistapaa, missä ensin käydään läpi ylemmän tason binääristä rajoituspuuta (constraint tree). Rajoituspuun jokaisessa solmussa on joukko rajoitteita (tieto siitä milloin joku topologian solmu on jonkun toimijan varaama), jotka kuuluvat jollekin yksittäiselle toimijalle. Toisekseen rajoituspuun solmuihin on myös talletettu joukko alemmalta tasolta saatuja reittejä, yksi jokaista toimijaa kohti, joiden tulee olla vapaita tiedetyistä yhteentörmäyksistä. Kolmantena niissä on myös yhteenlaskettu solmun reittikustannus, joka koostuu yksittäisen toimijan koko siihenastisen polun kustannuksesta. Rajoituspuu on järjestetty reittikustannuksen mukaan.

Alemmalla tasolla puolestaan voidaan käyttää tavanomaista yhden toimijan reitinhakualgoritmia kuten A* käyttäen samalla hyväksi ylemmältä tasolta saatua tietoa siitä, milloin ja missä on odotettavissa yhteentörmäys jonkun toisen toimijan kanssa. Mikäli kaikesta huolimatta alemmalla tasolla havaitaan yhteentörmäyksiä, päivitetään ylemmän tason rajoituspuuta vastaavasti ja laajennetaan rajoituspuuta lisäämällä siihen solmuja uusin rajoittein. 
[selvennys, solmujen lapset]
\newline

Meta-agent Conflict-Based Search (MA-CBS)

Improved Conflict-Based Search (ICBS)



\begin{algorithm}
\caption{ICBS-algoritmin ylempi taso}
\label{alg_icbs}
\begin{algorithmic}[1]
\State\textbf{Main(MAPF problem} instance\textbf{)}
	\State\indent Init $R$ with low-level paths for the individual agents
	\State\indent insert $R$ into OPEN
	\State\indent\textbf{while} OPEN $not$ $empty$ \textbf{do}
		\State\indent\indent $N\leftarrow$ best node from OPEN \textit{// lowest solution cost}
		\State\indent\indent Simulate the paths in $N$ and find all conflicts
		\State\indent\indent\textbf{if} $N$ \textit{has no conflict} \textbf{then}
		\State\indent\indent\indent\textbf{return} $N.solution$ \textit{// N is goal}
		\State\indent\indent $C\leftarrow$ find-cardinal/semi-cardinal-conflict($N$) \textit{// (PC)}
		\State\indent\indent\textbf{if} \textit{C is not cardinal} \textbf{then}
			\State\indent\indent\indent\textbf{if} \textit{Find-bypass(N, C)} \textbf{then} \textit{// (BP)}
				\State\indent\indent\indent\indent Continue
		\State\indent\indent\textbf{if} \textit{should-merge($a_i$, $a_j$)} \textbf{then} \textit{// Optional, MA-CBS:}
			\State\indent\indent\indent $a_{ij}$ = merge($a_i$, $a_j$)
			\State\indent\indent\indent\textbf{if} \textit{MR active} \textbf{then} \textit{// (MR)}
				\State\indent\indent\indent\indent Restart search
			\State\indent\indent\indent Update N.constraints()
			\State\indent\indent\indent Update N.solution by invoking low-level($a_{ij}$)
			\State\indent\indent\indent Insert N back into OPEN
			\State\indent\indent\indent continue \textit{// go back to the while statement}
		\State\indent\indent\textbf{foreach} \textit{agent $a_i$ in C} \textbf{do}
			\State\indent\indent\indent $A\leftarrow$ Generate Child($N$, (\textit{$a_i$, s, t}))
			\State\indent\indent\indent Insert $A$ into OPEN
\newline
\State\textbf{Generate Child(Node $N$, Constraint $C$ =} \textit{($a_i$, s, t)}\textbf{)}
\State\indent$A.constraints\leftarrow$ $N.constraints$ + \textit{($a_i$, s, t)}
\State\indent$A.solution\leftarrow N.solution$
\State\indent Update $A.solution$ by invoking \textit{low level}($a_i$)
\State\indent$A.cost\leftarrow$ \textit{SIC}($A.solution$)
\State\indent\textbf{return} $A$

\end{algorithmic}
\end{algorithm}


\section{Muut rinnakkaisen reitinhaun algoritmit}

\subsection{Multi-agent Rapidly-exploring Random Tree (MA-RRT*)}



\subsection{Increasing Cost Tree Search}

Guni Sharon ja kumppanit esittelivät vuoden 2012 artikkelissaan ~\cite{sharon2013} ICTS-menetelmän. Tässä on kyse kaksitasoisesta hierarkiasta, missä ylemmällä tasolla on puurakenne, jonka jokaisessa solmussa on yksiulotteinen taulukko kaikista mahdollsista reiteistä, missä 

\begin{algorithm}
\caption{Increasing Cost Tree}
\label{alg_icts}
\begin{algorithmic}[1]
\State\textbf{Input:} \emph{(k, n)} MAPF
\State Build the root of the ICT
\State\textbf{foreach} \emph{ICT node in a breadth-first manner} \textbf{do}
\State\indent\textbf{foreach} \emph{agent $a_i$} \textbf{do}
\State\indent\indent Build the corresponding $MDD_i$
\State\indent\textbf{[}\indent\textbf{//optional}
\State\indent\textbf{foreach} \emph{pair (triple) of agents} \textbf{do}
\State\indent\indent Perform node-pruning
\State\indent\indent\textbf{if} \emph{node-pruning failed} \textbf{then}
\State\indent\indent\indent\textbf{Break} \emph{//Conflict found. Next ICT node}
\State\indent\textbf{]}
\State\indent Search the $k$-agent MDD search space \emph{// low-level search}
\State\indent\textbf{if} \emph{goal node was found} \textbf{then}
\State\indent\indent\textbf{return} Solution
\end{algorithmic}
\end{algorithm}



\section{Yhteenveto}

% --- References ---
%
% bibtex is used to generate the bibliography. The babplain style
% will generate numeric references (e.g. [1]) appropriate for theoretical
% computer science. If you need alphanumeric references (e.g [Tur90]), use
%
% \bibliographystyle{babalpha-lf}
%
% instead.

\pagebreak

\bibliographystyle{unsrt}
% \bibliographystyle{babplain-lf}
\bibliography{references-fi}


% --- Appendices ---

% uncomment the following

% \newpage
% \appendix
% 
% \section{Esimerkkiliite}

\end{document}
